# -*- mode: org; -*-
* TODO reflection on tokens
  should we use =reflect.Typeof()=, possibly doing comparison with null
  instantiations; string comparison on =Name()=; or just use ints in
  =token.Token()=?

  it would be nice to have lightweight and general comparison
  predicates: =IsToken(token, lexer.DONE)=; =IsDone(token)=, etc.

  we could force every token type to implement =IsDone()=,
  =IsOperator()= in the interface, of course. all very cumbersome.

  =match=, too, would have to take a predicate in that case; not an
  integer.

  #+BEGIN_SRC go
    func IsToken(token *token, type *token) bool {
        return reflect.Typeof(token) == reflect.Typeof(type)
    }
  #+END_SRC
* TODO position
  ah, very clever; they have: byte offset and filename in addition:

  #+BEGIN_SRC go
    type Position struct {
        Filename string // filename, if any
        Offset   int    // byte offset, starting at 0
        Line     int    // line number, starting at 1
        Column   int    // column number, starting at 1 (character count)
    }
  #+END_SRC
* DONE as opposed to explicitly copying struct
  CLOSED: [2010-06-07 Mon 04:46]
  exploit the copy-on-pass-by-value semantics.
* TODO file
  at some point, lexan is going to have to accept files/input streams.
* TODO repl
  - forked, compilable :: http://github.com/qrush/go-repl
  - bash-based :: http://sigpipe.org/go/tools/gorepl
* TODO lineNumber as pointer
  should we just take an int and return the new int, updating
  optionally on the calling side?

  state struct, including line number?
* TODO Value() and err
  thet fact that Value() returns an error means that we're already
  doing some parsing in the lexer; though the book mentioned that the
  phases are not utterly distinct, shouldn't we practice it thus
  initially?
* TODO token struct
  interesting: their token struct include regular expressions (mine,
  merely predicates?):
  http://search.cpan.org/~pscust/ParseLex-2.19/lib/Parse/Token.pm
* TODO fmt.Scan
  S-expressions over a Scan interface: http://pastie.org/979383

  Scan handles the mechanics, apparently, of rune-by-rune processing.
